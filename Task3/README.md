Материалы

scipy.optimize: http://docs.scipy.org/doc/scipy/reference/optimize.html
Matplotlib User Guide: http://matplotlib.org/users/index.html

Задача 1. Минимизация гладкой функции

Рассмотрим функцию: f(x) = sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2) на промежутке [1, 30]
Нужно найти минимум функции на заданном промежутке с помощью scipy.optimize.
Реализуйте функцию, вычисляющую f(x). (не забывайте, что целые числа делятся нацело).
Изучите примеры использования scipy.optimize.minimize (http://docs.scipy.org/doc/scipy/reference/optimize.html)
Найдите минимум, используя стандартные параметры в функции scipy.optimize.minimize. Поменяйте начальное приближение и посмотрите, меняется ли результат.
Укажите в scipy.optimize.minimize метода BFGS (один из самых точных в большинстве случаев градиентных методов оптимизации), запустите из начального приближения x=2. Градиент функции при этом указывать не нужно – он будет оценен численно. Полученное значение функции в точке минимума - ваш первый ответ по заданию 1, его надо записать с точностью до 2 знака после запятой.
Измените начальное приближение на x=30. Значение функции в точке минимума при указанном начальном значении - ваш второй ответ по заданию 1, его надо записать через пробел после первого, с точностью до 2 знака после запятой.
Почему ответ отличается в зависимости от начального приближения? Нарисуйте график функции.

Задача 2. Глобальная оптимизация

Применим к f(x) метод глобальной оптимизации — дифференциальную эволюцию (scipy.optimize.differential_evolution).
Обратите внимание, что границы значений аргументов функции представляют собой список кортежей (list, в который помещены объекты типа tuple).
Запустите поиск минимума функции f(x) с помощью дифференциальной эволюции на промежутке [1, 30]. Полученное значение функции в точке минимума - ответ в задаче 2. Запишите его с точностью до второго знака после запятой. В этой задаче ответ - только одно число.
Обратите внимание на результат, справился ли метод.
Сравните количество итераций, потребовавшихся BFGS для нахождения минимума при хорошем начальном приближении, с количеством итераций, потребовавшихся дифференциальной эволюции. При повторных запусках дифференциальной эволюции количество итераций будет меняться, но в этом примере, скорее всего, оно всегда будет сравнимым с количеством итераций BFGS. Однако в дифференциальной эволюции за одну итерацию требуется выполнить гораздо больше действий, чем в BFGS. Например, можно обратить внимание на количество вычислений значения функции (nfev) и увидеть, что у BFGS оно значительно меньше. Кроме того, время работы дифференциальной эволюции очень быстро растет с увеличением числа аргументов функции.

Задача 3. Минимизация негладкой функции

Рассмотрим функцию h(x) = int(f(x)) на том же отрезке [1, 30], т.е. теперь каждое значение f(x) приводится к типу int и функция принимает только целые значения.
Такая функция будет негладкой и даже разрывной. Какой вид имеет график функции h(x)? Постройте его с помощью matplotlib.
Попробуйте найти минимум функции h(x) с помощью BFGS, взяв в качестве начального приближения x=30. Получившееся значение функции – ваш первый ответ в этой задаче.
Теперь попробуйте найти минимум h(x) на отрезке [1, 30] с помощью дифференциальной эволюции. Значение функции h(x) в точке минимума – это ваш второй ответ в этом задании. Запишите его через пробел после предыдущего.
Различаются ли результаты? Почему именно такой минимум при использовании BFGS?
